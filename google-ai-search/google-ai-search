#!/usr/bin/env python3
"""
google-ai-search - Kommandozeilen-Tool f√ºr Google Search AI via Gemini API

Direkte API-Nutzung ohne externes gemini CLI.
"""

import argparse
import sys
import json
import os
import re
from pathlib import Path

# Optional: requests verwenden wenn verf√ºgbar, sonst urllib
try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    import urllib.request
    import urllib.error
    import urllib.parse
    import ssl


API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta"
DEFAULT_MODEL = "gemini-1.5-flash-latest"


class Colors:
    """ANSI Farbcodes f√ºr Terminal-Output"""
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    RESET = '\033[0m'


def load_config():
    """L√§dt Konfiguration aus config.json im Tool-Verzeichnis"""
    config_path = Path(__file__).parent / "config.json"
    if config_path.exists():
        try:
            with open(config_path) as f:
                return json.load(f)
        except json.JSONDecodeError as e:
            print_error(f"Config-Datei ist kein g√ºltiges JSON: {e}")
        except Exception as e:
            print_error(f"Fehler beim Laden der Config: {e}")
    return {}


def get_api_key():
    """Holt API Key aus Umgebungsvariable oder Config-Datei"""
    # Priorit√§t 1: Umgebungsvariable
    env_key = os.environ.get("GEMINI_API_KEY")
    if env_key:
        return env_key
    
    # Priorit√§t 2: Config-Datei
    config = load_config()
    return config.get("gemini_api_key")


def print_error(msg):
    """Printet eine Fehlermeldung in Rot"""
    print(f"{Colors.RED}{Colors.BOLD}‚ùå Fehler:{Colors.RESET} {Colors.RED}{msg}{Colors.RESET}", file=sys.stderr)


def print_warning(msg):
    """Printet eine Warnung in Gelb"""
    print(f"{Colors.YELLOW}‚ö†Ô∏è  {msg}{Colors.RESET}", file=sys.stderr)


def print_success(msg):
    """Printet eine Erfolgsmeldung in Gr√ºn"""
    print(f"{Colors.GREEN}‚úÖ {msg}{Colors.RESET}")


def print_info(msg):
    """Printet eine Info in Cyan"""
    print(f"{Colors.CYAN}‚ÑπÔ∏è  {msg}{Colors.RESET}")


def validate_api_key(api_key):
    """Pr√ºft ob der API-Key g√ºltig aussieht"""
    if not api_key:
        return False, "Kein API Key gefunden"
    
    # Gemini API Keys sind typischerweise 39 Zeichen lang und starten mit "AIza..."
    if len(api_key) < 10:
        return False, "API Key sieht zu kurz aus"
    
    if not api_key.startswith("AIza"):
        print_warning("API Key startet nicht mit 'AIza' - typischerweise beginnen Gemini Keys damit")
    
    return True, None


def api_request_with_requests(url, data, headers, timeout=30):
    """Macht einen API Request mit requests library"""
    try:
        response = requests.post(url, json=data, headers=headers, timeout=timeout)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.Timeout:
        raise TimeoutError(f"Request hat {timeout}s √ºberschritten")
    except requests.exceptions.ConnectionError as e:
        raise ConnectionError(f"Verbindungsfehler: {e}")
    except requests.exceptions.HTTPError as e:
        if response.status_code == 400:
            raise ValueError(f"Ung√ºltige Anfrage (400): {response.text}")
        elif response.status_code == 401:
            raise PermissionError(f"Ung√ºltiger API Key (401). Pr√ºfe deinen GEMINI_API_KEY")
        elif response.status_code == 403:
            raise PermissionError(f"Zugriff verweigert (403). API Key hat m√∂glicherweise keine Berechtigung f√ºr Google Search")
        elif response.status_code == 429:
            raise RuntimeError(f"Rate limit √ºberschritten (429). Bitte warte einen Moment")
        elif response.status_code >= 500:
            raise RuntimeError(f"Serverfehler ({response.status_code}). Google API ist m√∂glicherweise nicht verf√ºgbar")
        else:
            raise RuntimeError(f"HTTP Fehler {response.status_code}: {response.text}")


def api_request_with_urllib(url, data, headers, timeout=30):
    """Macht einen API Request mit urllib (Fallback)"""
    try:
        request = urllib.request.Request(
            url,
            data=json.dumps(data).encode('utf-8'),
            headers=headers,
            method='POST'
        )
        
        # SSL Context der Zertifikate validiert
        context = ssl.create_default_context()
        
        with urllib.request.urlopen(request, timeout=timeout, context=context) as response:
            return json.loads(response.read().decode('utf-8'))
            
    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8')
        if e.code == 400:
            raise ValueError(f"Ung√ºltige Anfrage (400): {error_body}")
        elif e.code == 401:
            raise PermissionError(f"Ung√ºltiger API Key (401). Pr√ºfe deinen GEMINI_API_KEY")
        elif e.code == 403:
            raise PermissionError(f"Zugriff verweigert (403). API Key hat m√∂glicherweise keine Berechtigung f√ºr Google Search")
        elif e.code == 429:
            raise RuntimeError(f"Rate limit √ºberschritten (429). Bitte warte einen Moment")
        elif e.code >= 500:
            raise RuntimeError(f"Serverfehler ({e.code}). Google API ist m√∂glicherweise nicht verf√ºgbar")
        else:
            raise RuntimeError(f"HTTP Fehler {e.code}: {error_body}")
    except urllib.error.URLError as e:
        raise ConnectionError(f"Verbindungsfehler: {e.reason}")
    except TimeoutError:
        raise TimeoutError(f"Request hat {timeout}s √ºberschritten")


def make_api_request(url, data, headers, timeout=30):
    """W√§hlt die beste Methode f√ºr API Requests"""
    if HAS_REQUESTS:
        return api_request_with_requests(url, data, headers, timeout)
    else:
        return api_request_with_urllib(url, data, headers, timeout)


def search(query, model=None, json_output=False, raw=False, timeout=30, show_tools=False):
    """
    F√ºhrt eine Google Search AI Abfrage durch
    
    Args:
        query: Die Suchanfrage
        model: Optional ein bestimmtes Gemini-Modell
        json_output: JSON-Format ausgeben
        raw: Rohe Ausgabe ohne Formatierung
        timeout: Timeout in Sekunden
        show_tools: Zeige verwendete Tools an
    """
    # API Key validieren
    api_key = get_api_key()
    is_valid, error_msg = validate_api_key(api_key)
    
    if not is_valid:
        print_error(error_msg)
        print(f"\n{Colors.BOLD}So kannst du einen API Key hinzuf√ºgen:{Colors.RESET}")
        print(f"  1. Umgebungsvariable: {Colors.CYAN}export GEMINI_API_KEY='dein-key'{Colors.RESET}")
        print(f"  2. Config-Datei: {Colors.CYAN}{Path(__file__).parent}/config.json{Colors.RESET}")
        print(f"\n{Colors.BOLD}API Key erstellen:{Colors.RESET}")
        print(f"  ‚Üí https://makersuite.google.com/app/apikey")
        sys.exit(1)
    
    model = model or DEFAULT_MODEL
    
    # API Endpoint
    url = f"{API_BASE_URL}/models/{model}:generateContent?key={api_key}"
    
    # Request Body mit Google Search Tool
    data = {
        "contents": [{
            "parts": [{
                "text": f"""Beantworte folgende Frage mit aktuellen Informationen aus dem Internet:

{query}

Wichtig:
- Nutze Google Search f√ºr aktuelle Informationen
- Zitiere Quellen mit URLs wenn m√∂glich
- Antworte auf Deutsch (wenn die Frage auf Deutsch ist)
- Sei pr√§gnant aber vollst√§ndig"""
            }]
        }],
        "tools": [{
            "google_search": {}
        }],
        "generationConfig": {
            "temperature": 0.7,
            "maxOutputTokens": 2048
        }
    }
    
    headers = {
        "Content-Type": "application/json"
    }
    
    try:
        if not json_output and not raw:
            print_info(f"Frage Gemini ({model}) mit Google Search...")
        
        result = make_api_request(url, data, headers, timeout)
        
        # Antwort extrahieren
        candidates = result.get("candidates", [])
        if not candidates:
            print_error("Keine Antwort von der API erhalten")
            if "promptFeedback" in result:
                feedback = result["promptFeedback"]
                if "blockReason" in feedback:
                    print_error(f"Anfrage blockiert: {feedback['blockReason']}")
            sys.exit(1)
        
        content = candidates[0].get("content", {})
        parts = content.get("parts", [])
        
        if not parts:
            print_error("Leere Antwort von der API")
            sys.exit(1)
        
        text_response = parts[0].get("text", "")
        
        # Grounding-Infos extrahieren (Quellen)
        grounding = candidates[0].get("groundingMetadata", {})
        sources = []
        
        if "groundingChunks" in grounding:
            for chunk in grounding["groundingChunks"]:
                if "web" in chunk:
                    web = chunk["web"]
                    sources.append({
                        "title": web.get("title", "Unbekannt"),
                        "uri": web.get("uri", "")
                    })
        
        # Verwendete Tools anzeigen
        if show_tools and not json_output and not raw:
            print(f"\n{Colors.CYAN}üîß Verwendete Tools:{Colors.RESET}")
            print(f"  ‚Ä¢ Google Search")
            if sources:
                print(f"  ‚Ä¢ {len(sources)} Quellen gefunden")
            print()
        
        # Output formatieren
        if json_output:
            output = {
                "query": query,
                "model": model,
                "response": text_response,
                "sources": sources
            }
            print(json.dumps(output, indent=2, ensure_ascii=False))
        elif raw:
            print(text_response)
        else:
            print(f"\n{text_response}\n")
            
            # Quellen anzeigen
            if sources:
                print(f"{Colors.CYAN}üìö Quellen:{Colors.RESET}")
                seen_uris = set()
                for i, source in enumerate(sources[:5], 1):  # Max 5 Quellen
                    uri = source["uri"]
                    if uri not in seen_uris:
                        seen_uris.add(uri)
                        title = source["title"]
                        # URL k√ºrzen wenn zu lang
                        display_uri = uri if len(uri) < 70 else uri[:67] + "..."
                        print(f"  {i}. {Colors.BOLD}{title}{Colors.RESET}")
                        print(f"     {Colors.BLUE}{display_uri}{Colors.RESET}")
                print()
                
    except PermissionError as e:
        print_error(str(e))
        print(f"\n{Colors.BOLD}L√∂sung:{Colors.RESET}")
        print("  1. Erstelle einen neuen API Key: https://makersuite.google.com/app/apikey")
        print("  2. Aktiviere die Gemini API in der Google Cloud Console")
        print("  3. Pr√ºfe ob dein Projekt Billing hat (f√ºr Search-Features n√∂tig)")
        sys.exit(1)
        
    except ConnectionError as e:
        print_error(str(e))
        print(f"\n{Colors.BOLD}M√∂gliche Ursachen:{Colors.RESET}")
        print("  ‚Ä¢ Keine Internetverbindung")
        print("  ‚Ä¢ Firewall/Proxy blockiert den Zugriff")
        print("  ‚Ä¢ DNS-Probleme")
        sys.exit(1)
        
    except TimeoutError as e:
        print_error(str(e))
        print(f"\n{Colors.BOLD}Tipps:{Colors.RESET}")
        print(f"  ‚Ä¢ Erh√∂he das Timeout: --timeout 60")
        print(f"  ‚Ä¢ Probiere ein kleineres Modell: --model gemini-1.5-flash")
        print(f"  ‚Ä¢ Vereinfache deine Anfrage")
        sys.exit(1)
        
    except ValueError as e:
        print_error(str(e))
        sys.exit(1)
        
    except RuntimeError as e:
        print_error(str(e))
        sys.exit(1)
        
    except Exception as e:
        print_error(f"Unerwarteter Fehler: {e}")
        if os.environ.get("DEBUG"):
            import traceback
            traceback.print_exc()
        sys.exit(1)


def interactive_mode():
    """Interaktiver Modus f√ºr wiederholte Abfragen"""
    print(f"{Colors.CYAN}{Colors.BOLD}üîç Google AI Search - Interaktiver Modus{Colors.RESET}")
    print("Tippe 'exit' oder 'quit' zum Beenden\n")
    
    # API Key pr√ºfen
    api_key = get_api_key()
    if not api_key:
        print_error("Kein API Key gefunden. Bitte zuerst einrichten.")
        sys.exit(1)
    
    print_success("API Key gefunden. Bereit f√ºr Anfragen.\n")
    
    while True:
        try:
            query = input(f"{Colors.BOLD}Suche >{Colors.RESET} ").strip()
            
            if query.lower() in ("exit", "quit", "q"):
                print(f"\n{Colors.GREEN}üëã Auf Wiedersehen!{Colors.RESET}")
                break
            
            if not query:
                continue
            
            print()
            search(query, show_tools=True)
            
        except KeyboardInterrupt:
            print(f"\n\n{Colors.GREEN}üëã Auf Wiedersehen!{Colors.RESET}")
            break
        except EOFError:
            break


def main():
    parser = argparse.ArgumentParser(
        description="Google Search AI via Gemini API - Kommandozeilen-Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
{Colors.BOLD}Beispiele:{Colors.RESET}
  google-ai-search "Aktueller Stand von Fusion Energy"
  google-ai-search --json "Wetter in Z√ºrich morgen"
  google-ai-search --model gemini-1.5-pro "Python 3.12 neue Features"
  google-ai-search -i                    # Interaktiver Modus

{Colors.BOLD}Hinweise:{Colors.RESET}
  ‚Ä¢ API Key wird aus GEMINI_API_KEY Umgebungsvariable oder config.json gelesen
  ‚Ä¢ Erstelle einen API Key unter: https://makersuite.google.com/app/apikey
  ‚Ä¢ F√ºr Google Search muss das Projekt Billing haben
        """
    )
    
    parser.add_argument(
        "query",
        nargs="?",
        help="Die Suchanfrage (optional im interaktiven Modus)"
    )
    
    parser.add_argument(
        "-i", "--interactive",
        action="store_true",
        help="Interaktiver Modus f√ºr wiederholte Abfragen"
    )
    
    parser.add_argument(
        "-m", "--model",
        default=None,
        help=f"Gemini-Modell (default: {DEFAULT_MODEL})"
    )
    
    parser.add_argument(
        "-j", "--json",
        action="store_true",
        help="Ausgabe als JSON"
    )
    
    parser.add_argument(
        "-r", "--raw",
        action="store_true",
        help="Rohe Ausgabe ohne Formatierung"
    )
    
    parser.add_argument(
        "-t", "--timeout",
        type=int,
        default=30,
        help="Timeout in Sekunden (default: 30)"
    )
    
    parser.add_argument(
        "--show-tools",
        action="store_true",
        help="Zeige verwendete Tools an"
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version="%(prog)s 2.0.0"
    )
    
    args = parser.parse_args()
    
    # Interaktiver Modus
    if args.interactive:
        interactive_mode()
        return
    
    # Query muss angegeben sein
    if not args.query:
        parser.print_help()
        sys.exit(1)
    
    # Normale Suche
    search(
        args.query, 
        args.model, 
        args.json, 
        args.raw, 
        args.timeout,
        args.show_tools
    )


if __name__ == "__main__":
    main()
